package edu.berkeley.nlp.assignments.assign1.student;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import edu.berkeley.nlp.langmodel.EnglishWordIndexer;
import edu.berkeley.nlp.langmodel.NgramLanguageModel;
import edu.berkeley.nlp.util.CollectionUtils;
import edu.berkeley.nlp.util.StringIndexer;

public class ExactLm implements NgramLanguageModel
{
	long total = 0;

	static final int mask_19 = ~0 >>> (32 - 19);
	static final int mask_25 = ~0 >>> (32 - 25);

	private StringIndexer indexer = EnglishWordIndexer.getIndexer();
	private int START = indexer.addAndGetIndex(NgramLanguageModel.START);
	private int STOP = indexer.addAndGetIndex(NgramLanguageModel.STOP);
	private int 
EMPTY = indexer.addAndGetIndex("<e>");
	
	long[][] bigrams = new long[1000][];
	int[] bigrams_count = new int[1000];
	int[] hashcodes = new int[1000];
	int[] unigram_counts = new int[1000];

	public ExactLm(Iterable<List<String>> sentenceCollection) {
		System.out.println("Building ExactLm . . . ");
		int sent = 0;
		
		long start = System.nanoTime();
		
		for (List<String> sentence : sentenceCollection) {
			sent++;
			// long resize_toplayer_time = 0, resize_hash_time = 0, add_time = 0, find_time = 0;
			/* if (sent % 10000 == 0) System.out.printf("%d,%f,%d,%d,%d,%f,%f,%d,%f,%d,%f,%d,%f,%d\n", 
					sent, (System.nanoTime() - start) / 1000000000., num_looks, num_finds, num_avoided, (double) num_looks/num_finds, (double) num_avoided/num_finds,
					resize_toplayer_time, (double)resize_toplayer_time/add_time, resize_hash_time, (double)resize_hash_time/add_time, find_time, (double)find_time/add_time, add_time
					);*/
			if (sent % 10000 == 0) System.out.printf("%d,%f\n",sent, (System.nanoTime() - start) / 1000000000.);
			
			int[] stoppedSentence = new int[sentence.size() + 2];
			stoppedSentence[0] = START;
			stoppedSentence[stoppedSentence.length - 1] = STOP;
			
			int i = 0;
			
			for (String word : sentence) {
				stoppedSentence[++i] = indexer.addAndGetIndex(word);
			}
			
			for (i = 0; i < stoppedSentence.length; ++i) {
				// add stoppedSentence[i]
				//addWord(EMPTY, EMPTY, stoppedSentence.get(i));
				
				// add stoppedSentence[i ... i+1]
				if (i < stoppedSentence.length - 1)
					addWord(stoppedSentence[i], stoppedSentence[i + 1], EMPTY);
				
				// add stoppedSentence[i ... i+2]
				if (i < stoppedSentence.length - 2) {
					addWord(stoppedSentence[i], stoppedSentence[i + 1], stoppedSentence[i + 2]);
				}
			}
		}
		System.out.println("Done building ExactLm. Took " + (System.nanoTime() - start) / 1000000000. + " seconds.");
		
		System.out.println("Compacting data structure.");
		
		start = System.nanoTime();
		
		long[][] new_bigrams = new long[EnglishWordIndexer.getIndexer().size()][];
		
		int numTrigrams = 0;
		
		for (int i = 0; i < new_bigrams.length; i++) {
			if (bigrams_count[i] > 0) {
				new_bigrams[i] = new long[bigrams_count[i]];
				int j = 0;
				for (long entry : bigrams[i]) {
					if (entry != 0) {
						total += entry & mask_25;
						
						new_bigrams[i][j] = entry;
						
						++j;
					}
				}
				
				Arrays.sort(new_bigrams[i]);
				
				bigrams[i] = null; // make gc happy
				
				numTrigrams += bigrams_count[i];
			}
		}
		
		bigrams = new_bigrams;
		
		// make gc happy
		bigrams_count = null; 
		hashcodes = null;
		
		System.out.println("Done compacting. Took " + (System.nanoTime() - start) / 1000000000. + " seconds.");

		System.out.println("Number of trigrams: " + numTrigrams);
		System.out.println("Number of bigrams: " + bigrams[EMPTY].length);
		System.out.println("Number of word types (unigrams): " + new_bigrams.length);
		System.out.println("Total tokens: " + total);
		System.out.println("Sentences: " + sent);
		// total = CollectionUtils.sum(wordCounter);
	}

	/*
	 * Binary search to find the minimum index such that the key is at least the value of the key in the table
	 */
	private int indexOf(int word1, long key) {
		long[] bigram_table = bigrams[word1];
		
		int min = 0;
		int max = bigrams_count[word1];
		
		key <<= 25;
		
		do {
			int mid = min + (max - min) / 2;
			if (key > bigram_table[mid]) {
				min = mid + 1;
			} else {
				max = mid;
			}
		} while (min < max);
		
		// assert (min == bigrams_count[word1] && bigrams_table[min - 1] < key) or ()
		return min;
	}
	long  num_looks = 0, num_finds = 0, num_avoided = 0;
	
	private int findIndex(long[] table, int index, long key) {
		// num_finds++;
		index = index % table.length;
		// int i = index;
		
		while (table[index] != 0 && (table[index] >>> 25) != key) {
			index = (index+1) % table.length;
		}
		
		// int num_looks_local = (index - i + table.length) % table.length;
		
		// num_looks += num_looks_local;
		// num_avoided += table.length - num_looks_local;
		return index;
	}

	// long resize_toplayer_time = 0, resize_hash_time = 0, add_time = 0, find_time = 0;
	
	private void addWord(int word1, int word2, int word3) {
		// add_time -= System.nanoTime();
		while (word1 >= bigrams.length || word2 >= bigrams.length || word3 >= bigrams.length) {
			// resize_toplayer_time -= System.nanoTime();
			// double the array
			long[][] ret = new long[bigrams.length * 2][];
			System.arraycopy(bigrams, 0, ret, 0, bigrams.length);
			bigrams = ret;
			
			bigrams_count = CollectionUtils.copyOf(bigrams_count, bigrams.length);
			hashcodes = CollectionUtils.copyOf(hashcodes, bigrams.length);

			if (hashcodes[word2] == 0) {
				hashcodes[word2] = indexer.get(word2).hashCode();
			}
			
			if (hashcodes[word3] == 0) {
				hashcodes[word3] = indexer.get(word3).hashCode();
			}
			
			// resize_toplayer_time += System.nanoTime();
		}
		
		long[] bigram_table = bigrams[word1];
		long key = bigram_key(word2, word3);
		
		// first time we've seen the word
		if (bigram_table == null) {
			bigrams[word1] = new long[10];
			bigrams[word1][0] = compose(key, 1);
			bigrams_count[word1] = 1;
			hashcodes[word1] = indexer.get(word1).hashCode();
		} else {
			int index = hash(word1, word2, word3);

			// find_time -= System.nanoTime();
			int i = findIndex(bigram_table, index, key);
			// find_time += System.nanoTime();
			
			// new entry
			if (bigram_table[i] == 0) {
				bigram_table[i] = compose(key, 1);
				++bigrams_count[word1];

				// resize?
				if (bigrams_count[word1] >= bigram_table.length / 2) {
					// resize_hash_time -= System.nanoTime();
					long[] new_table = new long[3 * bigram_table.length / 2];
					for (long entry : bigram_table) {
						if (entry != 0) {
							long entry_key = entry >>> 25;
							int entry_word2 = (int) (entry_key >>> 19);
							int entry_word3 = (int) (entry_key & mask_19);
							int entry_index = hash(word1, entry_word2, entry_word3);
							
							new_table[findIndex(new_table, entry_index, entry_key)] = entry;
						}
					}

					bigrams[word1] = new_table;
					// resize_hash_time += System.nanoTime();
				}
			// Found it
			} else if ((bigram_table[i] >>> 25) == key) {
				// pretend there's no overflow
				++bigram_table[i];
			}
		}

		//add_time += System.nanoTime();
	}
	
	private int hash(int word1, int word2, int word3) {
		// assert hashcodes[word1] != 0 && hashcodes[word2] != 0 && hashcodes[word3] != 0;
		int h = (hashcodes[word1] >>> 7) ^ (hashcodes[word2] >>> 4) ^ (hashcodes[word3] >>> 1);
		return h;
	}
	
	private long bigram_key(long word2, long word3) {
		/* if ((word2 >>> 19) != 0 || (word3 >>> 19) != 0) {
			System.err.println("Error: Word doesn't fit in 19 bits");
			System.err.printf("%s, %d, %d, \n", Integer.toBinaryString(mask_19), word2, word3);
		}*/
		
		return (word2 << 19) | word3;
	}
	
	private long compose(long key, int count) {
		/* if ((count >>> 25) != 0) {
			System.err.println("Error: Count exceeded 25 bits");
		}*/ 
		return (key << 25) | count;
	}
	
	public int getOrder() {
		return 3;
	}
	
	public double getNgramLogProbability(int[] ngram, int from, int to) {
		/*double logProb = 0.0;
		for (int i = from; i < to; ++i) {

			final int word = ngram[i];
			double count = (word < 0 || word >= wordCounter.length) ? 1.0 : wordCounter[word];

			logProb += Math.log(count / (total + 1.0));
		}
		return logProb;*/
		
		return 0;
	}
	
	private long getCount(int word1, int word2, int word3) {
		// one of the word we've never seen before
		if (word1 >= bigrams.length || word2 >= bigrams.length || word3 >= bigrams.length || bigrams[word1] == null) {
			return 0;
		}
		long key = bigram_key(word2, word3);
		int index = indexOf(word1, key);
		
		if (index < bigrams_count[word1] && key == (bigrams[word1][index] >>> 25)) {
			return bigrams[word1][index] & mask_25;
		} else {
			return 0;
		}
	}

	public long getCount(int[] ngram) {
		switch (ngram.length) {
		case 3:
			return getCount(ngram[0], ngram[1], ngram[2]);
		case 2:
			return getCount(EMPTY, ngram[0], ngram[1]);
		case 1:
			return getCount(EMPTY, EMPTY, ngram[0]);
		default:
			return 0;
		}
	}
}
